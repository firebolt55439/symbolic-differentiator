"use strict";
var clc = require("cli-color");
var fs = require("fs");
var path = require("path");
var request = require("request");
var size = require("lodash/size");
var zlib = require("zlib");
var crypto = require("crypto");
var hashcache = require("./hashcache");
var detectProjectRoot = require("../../detectProjectRoot");
var api = require("../../api");
var logger = require("../../logger");
var Queue = require("../../queue");
var MIN_UPLOAD_TIMEOUT = 30000;
var MAX_UPLOAD_TIMEOUT = 7200000;
function _progressMessage(message, current, total) {
    current = Math.min(current, total);
    return (message +
        " [" +
        current +
        "/" +
        total +
        "] (" +
        clc.bold.green(Math.floor(((current * 1.0) / total) * 100).toString() + "%") +
        ")");
}
var Uploader = (function () {
    function Uploader(options) {
        this.version = options.version;
        this.cwd = options.cwd || process.cwd();
        this.projectRoot = detectProjectRoot(this.cwd);
        this.gzipLevel = options.gzipLevel || 9;
        this.hashQueue = new Queue({
            name: "hashQueue",
            concurrency: options.hashConcurrency || 50,
            handler: this.hashHandler.bind(this),
        });
        this.populateBatchSize = options.populateBatchSize || 1000;
        this.populateBatch = {};
        this.populateQueue = new Queue({
            name: "populateQueue",
            concurrency: options.populateConcurrency || 10,
            handler: this.populateHandler.bind(this),
            retries: 3,
        });
        this.uploadQueue = new Queue({
            name: "uploadQueue",
            concurrency: options.uploadConcurrency || 200,
            handler: this.uploadHandler.bind(this),
            retries: 5,
        });
        this.public = options.public || this.cwd;
        this.files = options.files;
        this.fileCount = this.files.length;
        this.cache = hashcache.load(this.projectRoot, this.hashcacheName());
        this.cacheNew = {};
        this.sizeMap = {};
        this.hashMap = {};
        this.pathMap = {};
    }
    Uploader.prototype.hashcacheName = function () {
        return Buffer.from(path.relative(this.projectRoot, this.public))
            .toString("base64")
            .replace(/=+$/, "");
    };
    Uploader.prototype.start = function () {
        var self = this;
        if (this.files.length === 0) {
            return Promise.resolve();
        }
        this.files.forEach(function (f) {
            self.hashQueue.add(f);
        });
        self.hashQueue.close();
        self.hashQueue.process();
        self.hashQueue
            .wait()
            .then(self.queuePopulate.bind(self))
            .then(function () {
            hashcache.dump(self.projectRoot, self.hashcacheName(), self.cacheNew);
            logger.debug("[hosting][hash queue][FINAL]", self.hashQueue.stats());
            self.populateQueue.close();
            return self.populateQueue.wait();
        })
            .then(function () {
            logger.debug("[hosting][populate queue][FINAL]", self.populateQueue.stats());
            logger.debug("[hosting] uploads queued:", self.uploadQueue.tasks.length);
            self.uploadQueue.close();
        });
        var fin = function (err) {
            logger.debug("[hosting][upload queue][FINAL]", self.uploadQueue.stats());
            if (err)
                throw err;
        };
        return this.wait()
            .then(fin)
            .catch(fin);
    };
    Uploader.prototype.wait = function () {
        return Promise.all([
            this.hashQueue.wait(),
            this.populateQueue.wait(),
            this.uploadQueue.wait(),
        ]).then(function () {
            return;
        });
    };
    Uploader.prototype.statusMessage = function () {
        if (!this.hashQueue.finished) {
            return _progressMessage("hashing files", this.hashQueue.complete, this.fileCount);
        }
        else if (!this.populateQueue.finished) {
            return _progressMessage("adding files to version", this.populateQueue.complete * 1000, this.fileCount);
        }
        else if (!this.uploadQueue.finished) {
            return _progressMessage("uploading new files", this.uploadQueue.complete, this.uploadQueue.tasks.length);
        }
        else {
            return "upload complete";
        }
    };
    Uploader.prototype.hashHandler = function (filePath) {
        var stats = fs.statSync(path.resolve(this.public, filePath));
        var mtime = stats.mtime.getTime();
        this.sizeMap[filePath] = stats.size;
        var cached = this.cache[filePath];
        if (cached && cached.mtime === mtime) {
            this.cacheNew[filePath] = cached;
            this.addHash(filePath, cached.hash);
            return Promise.resolve();
        }
        var fstream = this._zipStream(filePath);
        var hash = crypto.createHash("sha256");
        fstream.pipe(hash);
        var self = this;
        return new Promise(function (resolve, reject) {
            fstream.on("end", function () {
                var hashVal = hash.read().toString("hex");
                self.cacheNew[filePath] = { mtime: mtime, hash: hashVal };
                self.addHash(filePath, hashVal);
                resolve();
            });
            fstream.on("error", reject);
        });
    };
    Uploader.prototype.addHash = function (filePath, hash) {
        this.hashMap[hash] = filePath;
        this.pathMap[filePath] = hash;
        this.populateBatch["/" + filePath] = hash;
        this.populateCount++;
        var curBatchSize = size(this.populateBatch);
        if (curBatchSize > 0 && curBatchSize % this.populateBatchSize === 0) {
            this.queuePopulate();
        }
    };
    Uploader.prototype.queuePopulate = function () {
        var pop = this.populateBatch;
        this.populateQueue.add(pop, "batch" + (this.populateQueue.tasks.length + 1));
        this.populateBatch = {};
        this.populateQueue.process();
    };
    Uploader.prototype.populateHandler = function (batch) {
        var self = this;
        return api
            .request("POST", "/v1beta1/" + self.version + ":populateFiles", {
            origin: api.hostingApiOrigin,
            auth: true,
            data: { files: batch },
            logOptions: { skipRequestBody: true },
            timeout: 60000,
        })
            .then(function (result) {
            self.uploadUrl = result.body.uploadUrl;
            self.addUploads(result.body.uploadRequiredHashes || []);
        });
    };
    Uploader.prototype.addUploads = function (hashes) {
        var self = this;
        hashes.forEach(function (hash) {
            self.uploadQueue.add(hash);
        });
        self.uploadQueue.process();
    };
    Uploader.prototype.uploadHandler = function (toUpload) {
        var self = this;
        return api
            .addRequestHeaders({
            url: this.uploadUrl + "/" + toUpload,
        })
            .then(function (reqOpts) {
            return new Promise(function (resolve, reject) {
                self._zipStream(self.hashMap[toUpload]).pipe(request.post(Object.assign(reqOpts, {
                    timeout: self._uploadTimeout(self.hashMap[toUpload]),
                }), function (err, res) {
                    if (self.uploadQueue.cursor % 100 === 0) {
                        logger.debug("[hosting][upload]", self.uploadQueue.stats());
                    }
                    if (err) {
                        return reject(err);
                    }
                    else if (res.statusCode !== 200) {
                        logger.debug("[hosting][upload]", self.hashMap[toUpload], "(" + toUpload + ")", "HTTP ERROR", res.statusCode, ":", res.headers, res.body);
                        return reject(new Error("Unexpected error while uploading file."));
                    }
                    resolve();
                }));
            });
        });
    };
    Uploader.prototype._zipStream = function (filePath) {
        var gzip = zlib.createGzip({ level: this.gzipLevel });
        return fs.createReadStream(path.resolve(this.public, filePath)).pipe(gzip);
    };
    Uploader.prototype._uploadTimeout = function (filePath) {
        var size = this.sizeMap[filePath] || 0;
        return Math.min(Math.max(Math.round(size / 1000) * 20, MIN_UPLOAD_TIMEOUT), MAX_UPLOAD_TIMEOUT);
    };
    return Uploader;
}());
module.exports = Uploader;
//# sourceMappingURL=uploader.js.map