"use strict";
var _ = require("lodash");
var clc = require("cli-color");
var Readable = require("stream").Readable;
var configstore = require("./configstore");
var FirebaseError = require("./error");
var logger = require("./logger");
var isWindows = process.platform === "win32";
var ENV_OVERRIDES = [];
module.exports = {
    consoleUrl: function (project, path) {
        var api = require("./api");
        return api.consoleOrigin + "/project/" + project + path;
    },
    getInheritedOption: function (options, key) {
        var target = options;
        while (target) {
            if (_.has(target, key)) {
                return target[key];
            }
            target = target.parent;
        }
    },
    envOverride: function (envname, value, coerce) {
        if (process.env[envname] && process.env[envname].length) {
            ENV_OVERRIDES.push(envname);
            if (coerce) {
                try {
                    return coerce(process.env[envname], value);
                }
                catch (e) {
                    return value;
                }
            }
            return process.env[envname];
        }
        return value;
    },
    envOverrides: ENV_OVERRIDES,
    addSubdomain: function (origin, subdomain) {
        return origin.replace("//", "//" + subdomain + ".");
    },
    logSuccess: function (message, type) {
        type = type || "info";
        var chr = isWindows ? "+" : "✔";
        logger[type](clc.green(chr + " "), message);
    },
    logLabeledSuccess: function (label, message, type) {
        type = type || "info";
        var chr = isWindows ? "+" : "✔";
        logger[type](clc.green(chr + "  " + label + ":"), message);
    },
    logBullet: function (message, type) {
        type = type || "info";
        logger[type](clc.cyan.bold("i "), message);
    },
    logLabeledBullet: function (label, message, type) {
        type = type || "info";
        logger[type](clc.cyan.bold("i  " + label + ":"), message);
    },
    logWarning: function (message, type) {
        type = type || "warn";
        var chr = isWindows ? "!" : "⚠";
        logger[type](clc.yellow.bold(chr + " "), message);
    },
    reject: function (message, options) {
        return Promise.reject(new FirebaseError(message, options));
    },
    explainStdin: function () {
        if (isWindows) {
            throw new FirebaseError("STDIN input is not available on Windows.", {
                exit: 1,
            });
        }
        if (process.stdin.isTTY) {
            logger.info(clc.bold("Note:"), "Reading STDIN. Type JSON data and then press Ctrl-D");
        }
    },
    stringToStream: function (text) {
        if (!text) {
            return undefined;
        }
        var s = new Readable();
        s.push(text);
        s.push(null);
        return s;
    },
    makeActiveProject: function (projectDir, newActive) {
        var activeProjects = configstore.get("activeProjects") || {};
        if (newActive) {
            activeProjects[projectDir] = newActive;
        }
        else {
            _.unset(activeProjects, projectDir);
        }
        configstore.set("activeProjects", activeProjects);
    },
    endpoint: function (parts) {
        return "/" + _.join(parts, "/");
    },
    getFunctionsEventProvider: function (eventType) {
        var parts = eventType.split("/");
        if (parts.length > 1) {
            var provider = _.last(parts[1].split("."));
            return _.capitalize(provider);
        }
        if (eventType.match(/google.pubsub/)) {
            return "PubSub";
        }
        else if (eventType.match(/google.storage/)) {
            return "Storage";
        }
        else if (eventType.match(/google.analytics/)) {
            return "Analytics";
        }
        else if (eventType.match(/google.firebase.database/)) {
            return "Database";
        }
        else if (eventType.match(/google.firebase.auth/)) {
            return "Auth";
        }
        else if (eventType.match(/google.firebase.crashlytics/)) {
            return "Crashlytics";
        }
        else if (eventType.match(/google.firestore/)) {
            return "Firestore";
        }
        return _.capitalize(eventType.split(".")[1]);
    },
    promiseAllSettled: function (promises) {
        var wrappedPromises = _.map(promises, function (p) {
            return Promise.resolve(p)
                .then(function (val) {
                return { state: "fulfilled", value: val };
            })
                .catch(function (err) {
                return { state: "rejected", reason: err };
            });
        });
        return Promise.all(wrappedPromises);
    },
};
//# sourceMappingURL=utils.js.map